<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>PSO | Tomoya Onuki</title>
	    <link rel="stylesheet" type="text/css" href="../my.css">
    <script src="../sorce/my_processing/processing.min.js"></script>
</head>

<body class="body">
	<script type="text/javascript" src="./js/header.js"></script>

	<div>

		<h1 class="title first">PSO</h1>

		<div class="main">

			これは<string>粒子群最適化(Particle Swarm Optimization)アルゴリズム</string>を視覚化したものである。<br>
			粒子群最適化アルゴリズムは群知能の一種である。例えば昆虫の大群や魚群において、一匹がよさそうな経路を発見すると（すなわち、食料を発見したとか安全であるという場合）、群れの残りはどこにいても素早くそれに倣うことができる。<br>
			<br>
			ここでは関数の最小値を探索するものを制作した。ランダムにばらまかれた<strong>各粒子(Blue)</strong>が一定の速度で移動し<strong>最適な位置を更新</strong>し続ける。
			その中から<strong>群全体でもっとも最適な座標を決定</strong>する。これらの3つの座標によって<strong>速度は動的に更新</strong>され最適な位置を探索する。<br>
			位置の評価は適応度関数で行い、通知は最も良い位置にいる粒子による全体への通知とローカルなベストの位置にいる粒子による近傍の粒子群への通知の2種類の方法で行う。

			<p>
		Programing: Processing<br>
		</p>
		</div>

		<hr>
		<pre> </pre>
			<h2>
				<math>
					<mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><msup><mi>x</mi><mn>3</mn>
				</math>
			</h2>
			<center>
			 <script type="application/processing">
			    /*
*
*   y = x^4 + x^3
*
*/

int SIZE = 100;
Particle[] p = new Particle[SIZE];
Global global_best;
float w = 0.5;//慣性定数
float min_x = -10;//1*100
float max_x = 10;//10*100

void setup() {
  size(800, 400);
  frameRate(30);
  init();
}

void init(){
  //particleを初期化
  for(int i = 0; i < SIZE; i++){
    p[i] = new Particle(i);
    p[i].score = evaluation( p[i].x);
  }
  float best_score = p[0].score;
  int id = 0;
  for(int i = 0; i < SIZE; i++){
    if(best_score >= p[i].score){
      best_score = p[i].score;
      id = i;
    }
  }
  global_best = new Global(p[id].x);
}

void draw(){
  translate(width/2, height-100);

  background(255);
  //グラフの描画
  draw_graph();

  float pre_global_best_x = global_best.x;

  //println(global_best.x+", "+global_best.y);
  for(int i = 0; i < SIZE; i++){
    //描画
    p[i].draw();
    // global_best.draw();
    //座標の更新
    p[i].update_position();
    //新しい位置での評価値を取得
    p[i].score = evaluation( p[i].x );
    //パーソナルベストの更新
    p[i].update_best();
    //グローバルベストの更新
    global_best.update( p[i].x, p[i].score );
    //速度の更新
    p[i].update_velocity();
  }
  if(frameCount%50 == 0){
    init();
  }
}

//評価関数:良い値は小さい値
float evaluation(float x){
  float y = pow(x,4)+pow(x,3);
  return y;
}

class Global{
  float x, y;
  float score;

  Global(float _x){
    x = _x;
  }

  void update(float new_x, float _score){
    if( evaluation(x) > _score ){
      x = new_x;
    }
  }

  void draw() {
    stroke(255, 0, 0);
    strokeWeight(8);
    point(x*100, -evaluation(x)*100);
  }
}


class Particle{
  float x;
  float vx;
  float r1, r2;//[0,0.14] の範囲の値をとる乱数
  float best_x;//その粒子がこれまでに発見したベストな位置
  float score;

  Particle(int i){
    x = random(min_x, max_x);
    vx = 2;
    best_x = x;
  }

  void draw() {
    stroke(0, 0, 255);
    strokeWeight(8);
    point(x*100, -score*100);
    // stroke(0, 255, 0);
    // strokeWeight(5);
    // point(best_x*100, -evaluation(best_x)*100);
  }

  //座標の更新
  void update_position() {
    x += vx;
  }

  //ベストな座標の更新
  void update_best() {
    if( evaluation( best_x ) > score ){
      best_x = x;
    }
  }

  //速度の更新
  void update_velocity() {
    r1 = random(0, 0.14); r2 = random(0, 0.14);
    vx = w * vx + r1 * (best_x - x) + r2 * (global_best.x - x);
  }
}

//グラフの描画
void draw_graph() {
  strokeWeight(1); stroke(0);
  line(width/2, 0, -width, 0);
  line(0, height/2, 0, -height);
  //smooth();
  beginShape();
    for(float x = -100; x < 100; x+=0.001){
      point(x*100, -evaluation(x)*100 );
    }
  endShape(CLOSE);
}

void mousePressed(){
  init();
}

			 </script>
            <canvas></canvas>
		</center>
		<pre> </pre>
		<hr>
		<pre> </pre>
			<h2>
				<math>
					<mi>y</mi><mo>=</mo><msup><mi>x</mi><mn>2</mn>
				</math>
			</h2>
			<center>
			 <script type="application/processing">
			 /*
*
*   y = x^2
*
*/

int SIZE = 100;
Particle[] p = new Particle[SIZE];
Global global_best;
float w = 0.5;//慣性定数
float min_x = -10;//1*100
float max_x = 10;//10*100

void setup() {
  size(800, 400);
  frameRate(30);
  init();
}

void init(){
  //particleを初期化
  for(int i = 0; i < SIZE; i++){
    p[i] = new Particle(i);
    p[i].score = evaluation( p[i].x);
  }
  float best_score = p[0].score;
  int id = 0;
  for(int i = 0; i < SIZE; i++){
    if(best_score >= p[i].score){
      best_score = p[i].score;
      id = i;
    }
  }
  global_best = new Global(p[id].x);
}

void draw(){
  translate(width/2, height-100);

  background(255);
  //グラフの描画
  draw_graph();

  float pre_global_best_x = global_best.x;

  //println(global_best.x+", "+global_best.y);
  for(int i = 0; i < SIZE; i++){
    //描画
    p[i].draw();
    // global_best.draw();
    //座標の更新
    p[i].update_position();
    //新しい位置での評価値を取得
    p[i].score = evaluation( p[i].x );
    //パーソナルベストの更新
    p[i].update_best();
    //グローバルベストの更新
    global_best.update( p[i].x, p[i].score );
    //速度の更新
    p[i].update_velocity();
  }
  if(frameCount%50 == 0){
    init();
  }
}

//評価関数:良い値は小さい値
float evaluation(float x){
  float y = pow(x,2);
  return y;
}

class Global{
  float x, y;
  float score;

  Global(float _x){
    x = _x;
  }

  void update(float new_x, float _score){
    if( evaluation(x) > _score ){
      x = new_x;
    }
  }

  void draw() {
    stroke(255, 0, 0);
    strokeWeight(8);
    point(x*100, -evaluation(x)*100);
  }
}


class Particle{
  float x;
  float vx;
  float r1, r2;//[0,0.14] の範囲の値をとる乱数
  float best_x;//その粒子がこれまでに発見したベストな位置
  float score;

  Particle(int i){
    x = random(min_x, max_x);
    vx = 2;
    best_x = x;
  }

  void draw() {
    stroke(0, 0, 255);
    strokeWeight(8);
    point(x*100, -score*100);
    // stroke(0, 255, 0);
    // strokeWeight(5);
    // point(best_x*100, -evaluation(best_x)*100);
  }

  //座標の更新
  void update_position() {
    x += vx;
  }

  //ベストな座標の更新
  void update_best() {
    if( evaluation( best_x ) > score ){
      best_x = x;
    }
  }

  //速度の更新
  void update_velocity() {
    r1 = random(0, 0.14); r2 = random(0, 0.14);
    vx = w * vx + r1 * (best_x - x) + r2 * (global_best.x - x);
  }
}

//グラフの描画
void draw_graph() {
  strokeWeight(1); stroke(0);
  line(width/2, 0, -width, 0);
  line(0, height/2, 0, -height);
  //smooth();
  beginShape();
    for(float x = -100; x < 100; x+=0.001){
      point(x*100, -evaluation(x)*100 );
    }
  endShape(CLOSE);
}

void mousePressed(){
  init();
}

			 </script>
            <canvas></canvas>
		</center>
		<hr>
		<pre> </pre>
			<h2>
				<math>
					<mi>y</mi><mo>=</mo><msup><mrow><mi>(</mi><mi>log</mi><mi>x</mi><mi>)</mi></mrow><mn>2</mn></msup>
				</math>
			</h2>
			<center>
			 <script type="application/processing">
			 /*
*
*   y = (log x)^2
*
*/

int SIZE = 100;
Particle[] p = new Particle[SIZE];
Global global_best;
float w = 0.5;//慣性定数
float min_x = 1;//1*100
float max_x = 20;//10*100

void setup() {
  size(800, 400);
  frameRate(30);
  init();
}

void init(){
  //particleを初期化
  for(int i = 0; i < SIZE; i++){
    p[i] = new Particle(i);
    p[i].score = evaluation( p[i].x);
  }
  float best_score = p[0].score;
  int id = 0;
  for(int i = 0; i < SIZE; i++){
    if(best_score >= p[i].score){
      best_score = p[i].score;
      id = i;
    }
  }
  global_best = new Global(p[id].x);
}

void draw(){
  translate(width/2, height-100);

  background(255);
  //グラフの描画
  draw_graph();

  float pre_global_best_x = global_best.x;

  //println(global_best.x+", "+global_best.y);
  for(int i = 0; i < SIZE; i++){
    //描画
    p[i].draw();
    // global_best.draw();
    //座標の更新
    p[i].update_position();
    //新しい位置での評価値を取得
    p[i].score = evaluation( p[i].x );
    //パーソナルベストの更新
    p[i].update_best();
    //グローバルベストの更新
    global_best.update( p[i].x, p[i].score );
    //速度の更新
    p[i].update_velocity();
  }
  if(frameCount%50 == 0){
    init();
  }
}

//評価関数:良い値は小さい値
float evaluation(float x){
  float y = pow(log(x),2);
  return y;
}

class Global{
  float x, y;
  float score;

  Global(float _x){
    x = _x;
  }

  void update(float new_x, float _score){
    if( evaluation(x) > _score ){
      x = new_x;
    }
  }

  void draw() {
    stroke(255, 0, 0);
    strokeWeight(8);
    point(x*100, -evaluation(x)*100);
  }
}


class Particle{
  float x;
  float vx;
  float r1, r2;//[0,0.14] の範囲の値をとる乱数
  float best_x;//その粒子がこれまでに発見したベストな位置
  float score;

  Particle(int i){
    x = random(min_x, max_x);
    vx = 2;
    best_x = x;
  }

  void draw() {
    stroke(0, 0, 255);
    strokeWeight(8);
    point(x*100, -score*100);
    // stroke(0, 255, 0);
    // strokeWeight(5);
    // point(best_x*100, -evaluation(best_x)*100);
  }

  //座標の更新
  void update_position() {
    x += vx;
  }

  //ベストな座標の更新
  void update_best() {
    if( evaluation( best_x ) > score ){
      best_x = x;
    }
  }

  //速度の更新
  void update_velocity() {
    r1 = random(0, 0.14); r2 = random(0, 0.14);
    vx = w * vx + r1 * (best_x - x) + r2 * (global_best.x - x);
  }
}

//グラフの描画
void draw_graph() {
  strokeWeight(1); stroke(0);
  line(width/2, 0, -width, 0);
  line(0, height/2, 0, -height);
  //smooth();
  beginShape();
    for(float x = -100; x < 100; x+=0.001){
      point(x*100, -evaluation(x)*100 );
    }
  endShape(CLOSE);
}

void mousePressed(){
  init();
}

			 </script>
            <canvas></canvas>
		</center>
		<hr>
		<center style="font-size: 1.5vh; margin-top:30px; margin-bottom:80px;" class="main">
		<p>©️2017 - 2019 小貫智弥 | Tomoya Onuki</p>
		</center>
	</div>

</body>
</html>
